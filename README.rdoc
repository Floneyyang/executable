= Executable

{Website}[http://rubyworks.github.com/executable] |
{Source Code}[http://github.com/rubyworrks/executable] |
{Report Issue}[http://github.com/rubyworrks/executable/features] |
{#rubyworks}[irc://irc.freenode.org/rubyworks]

{<img src="http://travis-ci.org/rubyworks/executable.png" />}[http://travis-ci.org/rubyworks/executable]


== DESCRIPTION

Think of Executable as a *COM*, a Commandline Object Mapper,
in much the same way that ActiveRecord is an ORM,
an Object Relational Mapper. A class utilizing Executable
can define a complete command line tool using nothing more
than Ruby's own method definitions.

Executable is a very striaght-forward CLI framework for Ruby. CLI::Base is
a *COM* --a Command-to-Object Mapping library. A command line tool can be defined
using nothing more than Ruby's own standard syntax. No special DSL is required. 


== FEATURES

* Super easy to use, just mixin.
* Public writers become options.
* Public methods become subcommands.


== RELEASE NOTES

Please see HISTORY file.


== SYNOPSIS

Executable can be use as a mixin, or as a subclass via `Executable::Base`.
Add methods to you class to handle command-line options. Writer methods 
(those ending in '=') coorepsond to an options and a query method (those
ending in '?') mark an attribute as a flag option. 

For example, here is a simple "Hello, World!" commandline tool.

    require 'executable'

    class HelloCmd < Executable::Command
      # Say it in uppercase?
      def load=(bool)
        @loud = bool
      end

      #
      def loud?
        @loud
      end

      # Show this message.
      def help?
        cli.show_help
        exit
      end
      alias :h? :help?

      # Say hello.
      def call(name)
        name = name || 'World'
        str  = "Hello, #{name}!"
        str  = str.upcase if loud?
        puts str
      end
    end

To make the command available on the command line, add an executable
to your project passing ARGV to the #execute or #run methods.

    #!usr/bin/env ruby
    require 'hello.rb'
    HelloCmd.run(ARGV)

If we named this file `hello`, set its execute flag and made it available
via our systems $PATH, then:

    $ hello John
    Hello, World!

    $ hello John
    Hello, John!

    $ hello --loud John
    HELLO, JOHN!

Executable can also generate help text for commands.

    $ hello --help
    USAGE: hello [options]

    Say hello.

    --loud    Say it in uppercase?
    --help    Show this message

If you look back at the class definition you can see it's pulling
comments from the source to provide descriptions. 

Basic help like this is fine for personal tools, but for public facing
production applications it is desirable to utilize manpages. To this end,
Executable provides Markdown formatted help as well. We can access this,
for example, via `HelloCmd.help.to_markdown`. The idea with this is that
we can save the output to `man/hello.ronn` or copy it the top of our `bin/`
file, edit it to prefection and then use tools such a {ronn}[https://github.com/rtomayko/ronn],
{binman}[https://github.com/sunaku/binman] or {md2man}[https://github.com/sunaku/md2man]
to generate the manpages. What's particularly cool about Executable,
is that once we have a manpage, the `#show_help` will use it instead.

For a more detail example see {QED}[demo.html]
and {API}[http://rubydoc.info/gems/executable/frames] documentaiton.


== INSTALL

Install with RubyGems in the usual fashion.

  $ gem install executable


== LEGAL

Copyright (c) 2008 Rubyworks

Distributable in accordance with the *BSD-2-Clause* license.

See COPYING.rdoc for licensing details.

